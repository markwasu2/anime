<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Don’t Press Ignore</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0b0b12; --ui:#ffffff; --txt:#1B1B1B;
      --accent:#FF8FB1; --hover:#A3B7FF;
    }
    *{box-sizing:border-box}
    html,body{margin:0;height:100%;background:#000;font-family:Inter,system-ui,Segoe UI,Arial}
    .app{position:relative; width:100vw; height:100vh; overflow:hidden; background:#000;}
    canvas, .layer{position:absolute; inset:0}
    .bg{background:#000 center/cover no-repeat; filter:none; transition:filter .25s ease, opacity .2s}
    .bg.dim{filter:grayscale(.2) brightness(.9)}
    .bg.fade{opacity:0}
    .aiko{display:flex; align-items:center; justify-content:center; pointer-events:none; position:relative; min-height:60vh}
    .aiko img{max-height:80vh; max-width:85vw; object-fit:contain; transition:transform .2s ease, opacity .15s; position:relative; z-index:1}
    .aiko img.talking{transform:scaleY(1.015) translateY(-2px)}
    .aiko img.hide{display:none !important}
    .aiko canvas{position:absolute; inset:0; margin:auto; width:100%; height:100%; max-width:1280px; max-height:80vh; pointer-events:none; display:block}
    .ui{position:absolute; left:0; right:0; bottom:0; padding:22px; display:flex; justify-content:center}
    .dialogue{
      width:min(1200px,92vw); background:#fffF; backdrop-filter:blur(6px);
      border-radius:14px; box-shadow:0 10px 40px rgba(0,0,0,.35); padding:18px 18px 14px;
      border:1px solid rgba(0,0,0,.06)
    }
    .name{display:inline-block; background:var(--accent); color:#fff; border-radius:999px; padding:6px 14px; font-weight:700; margin-bottom:8px}
    .text{min-height:64px; font-size:18px; line-height:1.4; color:#111; letter-spacing:.2px; opacity:1; transition:opacity .18s}
    .text.fade{opacity:0}
    .btns{display:flex; gap:10px; justify-content:flex-end; margin-top:10px}
    button{
      appearance:none; border:0; border-radius:12px; padding:10px 16px; font-weight:700; cursor:pointer;
      background:var(--accent); color:#fff; box-shadow:0 6px 16px rgba(255,143,177,.35); transition:transform .05s ease, filter .1s ease, background .15s
    }
    .secondary{background:var(--hover); box-shadow:0 6px 16px rgba(163,183,255,.35)}
    button:active{transform:scale(.98)}
    .scan{position:absolute; inset:0; pointer-events:none; background:
      repeating-linear-gradient(to bottom, rgba(255,255,255,.03) 0 2px, transparent 2px 4px);
      mix-blend-mode:overlay; opacity:.15}
    .vignette{position:absolute; inset:0; pointer-events:none; box-shadow:inset 0 0 220px rgba(0,0,0,.8)}
    .glitch{position:absolute; inset:0; pointer-events:none; opacity:0; background:#fff}
    .glitch.flash{animation:flash .12s steps(2) 1}
    @keyframes flash {0%{opacity:.9} 100%{opacity:0}}
    .rgb{position:absolute; inset:0; mix-blend-mode:screen; pointer-events:none; opacity:0}
    .rgb.on{opacity:.25; animation:rgb .12s steps(2) 1}
    @keyframes rgb{
      0%{transform:translate(0,0)}
      50%{transform:translate(2px,0)}
      100%{transform:translate(0,0)}
    }
    .hud{position:absolute; top:14px; left:14px; color:#fff; font-size:12px; opacity:.35}
    /* Accessibility: reduce motion preference */
    @media (prefers-reduced-motion: reduce){
      *{transition:none !important; animation:none !important}
    }
  </style>
</head>
<body>
<div class="app" id="app">
  <div class="layer bg" id="bg" style="background-image:url('./assets/bg_school.jpg')"></div>
  <div class="layer aiko">
    <img id="aiko" src="./assets/aiko.png" alt="Aiko">
  </div>
  <div class="layer scan"></div>
  <div class="layer vignette"></div>
  <div class="layer glitch" id="glitch"></div>
  <div class="layer rgb" id="rgb"></div>

  <div class="ui">
    <div class="dialogue">
      <div class="name">Aiko ❤️</div>
      <div class="text" id="text"></div>
      <div class="btns">
        <button id="ignoreBtn">Ignore</button>
        <button class="secondary" id="changeBtn">Change Character</button>
      </div>
    </div>
  </div>

  <div class="hud">Press buttons or click anywhere to advance</div>
</div>

<audio id="sfxClick" src="./assets/click.mp3" preload="auto"></audio>
<audio id="sfxGlitch" src="./assets/glitch.mp3" preload="auto"></audio>
<audio id="music" src="./assets/audio/classroomidlemusic.mp3" preload="auto" loop></audio>
<audio id="hum" src="./assets/hum_low.mp3" preload="auto" loop></audio>
<audio id="staticNoise" src="./assets/audio/staticnoise.mp3" preload="auto"></audio>
<audio id="scaryRising" src="./assets/audio/DSGNRise-scary_creepy_rising_-Elevenlabs.mp3" preload="auto"></audio>
<audio id="jumpScare" src="./assets/audio/GOREMisc-Jump_scare_Hit-FX,_S-Elevenlabs.mp3" preload="auto"></audio>
<audio id="transitionBoom" src="./assets/audio/GOREMisc-transition_boom_to_n-Elevenlabs.mp3" preload="auto"></audio>
<audio id="demonicWhispers" src="./assets/audio/demonicwhispers.mp3" preload="auto" loop></audio>

<script>
/* --------- STATE & SCRIPT --------- */
// Put your Hume clips here if you have them; leave empty strings to skip.
const voice = [
  "./assets/audio/aiko_01.mp3", // Opening (combined)
  "./assets/audio/aiko_02.mp3", // Ignore #1
  "./assets/audio/aiko_03.mp3", // Ignore #2 (line 1)
  "./assets/audio/aiko_03.mp3", // Ignore #2 (line 2)
  "./assets/audio/aiko_04.mp3", // Ignore #3 → hurts
  "./assets/audio/aiko_05.mp3", // Recovery Qs (line1) - Are you tired?
  "./assets/audio/aiko_06.mp3", // Recovery Qs (line2) - You look pale
  "./assets/audio/aiko_07.mp3", // Change Character (line1)
  "./assets/audio/aiko_08.mp3", // Change Character (line2)
  "./assets/audio/aiko_09.mp3", // You always leave...
  "./assets/audio/aiko_10.mp3", // We're meant for each other
  "./assets/audio/aiko_11.mp3", // Noah... don't make me mad.
  "./assets/audio/aiko_12.mp3", // I know you better...
  "./assets/audio/aiko_13.mp3", // I know.
  "./assets/audio/aiko_14.mp3", // I'll fix you.
  "./assets/audio/aiko_15.mp3", // stay with me
  "./assets/audio/aiko_16.mp3", // You don't have to answer...
  "./assets/audio/aiko_17.mp3", // I'll do the talking...
  "./assets/audio/aiko_18.mp3", // Together as long as screen on
  ""                            // Forever's not that long (placeholder)
];

fetch("./assets/audio/aiko-voice-map.json")
  .then(res => res.ok ? res.json() : null)
  .then(map => {
    if (!Array.isArray(map)) return;
    map.forEach(item => {
      if (typeof item?.index === "number" && typeof item?.file === "string") {
        voice[item.index] = item.file;
      }
    });
  })
  .catch(()=>{});

const lines = [
  // Scene start (idle greeting) - combined opening
  "Hi… do you miss me? I miss you. Why don't you talk to me anymore?",
  // Ignore #1
  "That's not very nice.",
  // Ignore #2
  "Why are you being so mean to me?",
  "Don’t you love me anymore?",
  // Ignore #3 → brief static flicker
  "Why do you keep hurting me?",
  // Recovery check-in
  "Are you tired? Are you mad? Did you eat yet?",
  "You look pale again… you should rest.",
  // Change Character loopback
  "Why are you trying to talk to someone else?",
  "You already have me.",
  // Escalation
  "You always leave… but you still come back.",
  "We’re meant for each other, right?",
  // Silent beat → name reveal
  "Noah... don’t make me mad.",
  "I know you better than anyone.",
  // Final phase
  "I know.",
  "I’ll fix you.",
  "Just… stay with me, okay?",
  "You don’t have to answer anymore.",
  "I’ll do the talking.",
  "We can be together as long as this screen stays on.",
  // Whisper
  "Forever’s not that long."
];

const textEl = document.getElementById('text');
const aikoEl = document.getElementById('aiko');
const bgEl = document.getElementById('bg');
const glitchEl = document.getElementById('glitch');
const rgbEl = document.getElementById('rgb');
const sfxClick = document.getElementById('sfxClick');
const sfxGlitch = document.getElementById('sfxGlitch');
const music = document.getElementById('music');
const hum = document.getElementById('hum');
const staticNoise = document.getElementById('staticNoise');
const scaryRising = document.getElementById('scaryRising');
const jumpScare = document.getElementById('jumpScare');
const transitionBoom = document.getElementById('transitionBoom');
const demonicWhispers = document.getElementById('demonicWhispers');
const btnIgnore = document.getElementById('ignoreBtn');
const btnChange = document.getElementById('changeBtn');

let idx = 0;
let ignoreCount = 0;
let darkPhase = false;
let talk = new Audio();
let musicPrimed = false;
let firstInteraction = false;
let inputLocked = false;
let phase = 'light'; // 'light' | 'angry' | 'dark' | 'demon' | 'static' | 'bedroom' | 'final'
let audioCtx = null;
let bgmGainNode = null;
let queuedAdvance = false; // One-item input queue

// Emotion sprite mappings: [start_idx, end_idx, base_sprite]
const emotions = [
  {start: 0, end: 1, base: 'aiko'},        // Normal opening (combined)
  {start: 2, end: 4, base: 'clingy'},      // Needy/hurt (ignore strikes)
  {start: 5, end: 6, base: 'aiko'},        // False calm
  {start: 7, end: 12, base: 'angry'},      // Possessive/escalation
  {start: 13, end: 14, base: 'scary'},     // Dark phase begins
  {start: 15, end: 17, base: 'scary'},     // Threatening control
  {start: 18, end: 19, base: 'demon'}      // Demon reveal
];

function getBaseSprite(index){
  for(let e of emotions){
    if(index >= e.start && index <= e.end) return e.base;
  }
  return 'aiko';
}

/* --------- HELPERS --------- */
// Click debounce & input lock with queue
function withLock(fn, lockMs=250){
  return function(...args){
    if (inputLocked) {
      // Queue at most 1 advance
      queuedAdvance = true;
      return;
    }
    inputLocked = true;
    try { 
      fn.apply(this, args); 
    } finally {
      setTimeout(()=>{ 
        inputLocked = false;
        // Process queued advance if any
        if (queuedAdvance){
          queuedAdvance = false;
          inputLocked = true;
          setTimeout(()=>{ inputLocked = false; }, lockMs);
        }
      }, lockMs);
    }
  };
}

// iOS/Safari audio unlock
async function unlockAudio(){
  if (audioCtx && audioCtx.state === 'suspended'){
    await audioCtx.resume();
  }
}

function ensureMusic(){
  if (musicPrimed) return;
  musicPrimed = true;
  
  // Initialize Web Audio for BGM ducking
  if (!audioCtx){
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    bgmGainNode = audioCtx.createGain();
    bgmGainNode.gain.value = 0.35;
    bgmGainNode.connect(audioCtx.destination);
  }
  
  music.volume = .35;
  music.loop = true;
  music.play().catch(()=>{
    musicPrimed = false;
  });
  
  unlockAudio();
}

function ensureFirstAudio(){
  if (firstInteraction) return;
  firstInteraction = true;
  unlockAudio();
  // Replay line 0 audio on first interaction
  if (idx === 0 && voice[0]){
    say(0);
  }
}

// BGM ducking for voice (snappier timing)
function duckBGM(amount=0.15, attackMs=120){
  if (!bgmGainNode) return;
  const now = audioCtx.currentTime;
  bgmGainNode.gain.cancelScheduledValues(now);
  bgmGainNode.gain.linearRampToValueAtTime(amount, now + attackMs/1000);
}

function unduckBGM(releaseMs=350){
  if (!bgmGainNode) return;
  const now = audioCtx.currentTime;
  bgmGainNode.gain.cancelScheduledValues(now);
  bgmGainNode.gain.linearRampToValueAtTime(0.35, now + releaseMs/1000);
}

// Fade BGM to silence (for Scene 10 exit)
function fadeBGMToSilence(durationMs=350){
  if (!bgmGainNode) return;
  const now = audioCtx.currentTime;
  bgmGainNode.gain.cancelScheduledValues(now);
  bgmGainNode.gain.linearRampToValueAtTime(0.0001, now + durationMs/1000);
  setTimeout(()=>{
    if (music) music.pause();
  }, durationMs);
}

// BGM low-pass filter for Angry/Dark phases
let bgmFilterNode = null;
function applyBGMFilter(){
  if (!audioCtx || bgmFilterNode) return;
  
  bgmFilterNode = audioCtx.createBiquadFilter();
  bgmFilterNode.type = 'lowpass';
  bgmFilterNode.frequency.value = 1200; // 1.2 kHz
  bgmFilterNode.Q.value = 1.0;
  
  // Reduce volume for Angry phase
  if (bgmGainNode){
    bgmGainNode.gain.setValueAtTime(0.25, audioCtx.currentTime); // -8 dB approx
  }
  
  console.log('BGM filter applied: 1.2kHz LPF, -8dB');
}

// Phase management with CSS class reset
function setPhase(newPhase){
  phase = newPhase;
  console.log('Phase:', phase);
  
  // Reset background classes to prevent bleed
  bgEl.className = 'layer bg';
  
  // Re-apply phase-specific classes
  if (phase === 'angry' || phase === 'dark' || phase === 'demon'){
    bgEl.classList.add('dim');
  }
  
  // UI modality: Buttons ONLY in Light phase
  if (phase === 'light'){
    btnIgnore.style.display = '';
    btnChange.style.display = '';
  } else {
    btnIgnore.style.display = 'none';
    btnChange.style.display = 'none';
  }
  
  // Apply BGM filtering based on phase
  if (phase === 'angry' || phase === 'dark'){
    applyBGMFilter();
  }
  
  // Fade BGM at Scene 10 (lines 16-18)
  if (phase === 'dark' && idx >= 16){
    fadeBGMToSilence(350);
  }
}

// Stop all audio cleanly
function stopAllAudio(){
  music.pause();
  demonicWhispers.pause();
  staticNoise.pause();
  hum.pause();
  if (talk) talk.pause();
}

function say(i){
  // Variable micro-holds after Ignore strikes (makes system feel alive)
  let microHold = 0;
  if (i === 1) microHold = 80;   // After Ignore #1
  if (i === 2) microHold = 220;  // After Ignore #2
  if (i === 4) microHold = 120;  // After Ignore #3
  
  // 250ms ambient mute before Line 5 (false calm tension vacuum)
  if (i === 5){
    if (demonicWhispers) demonicWhispers.volume = 0;
    setTimeout(()=>{
      if (demonicWhispers && phase === 'dark') demonicWhispers.volume = 0.4;
    }, 250);
  }
  
  setTimeout(()=>{
    // Fade out old text
    textEl.classList.add('fade');
    setTimeout(()=>{
      textEl.textContent = lines[i] || "";
      textEl.classList.remove('fade');
    }, 140);
  }, microHold);

  // Determine base emotion sprite for this line
  const baseSprite = getBaseSprite(i);

  // Background transitions
  if(i === 2 && !bgEl.classList.contains('dim')){
    // Desaturate on first clingy moment
    bgEl.classList.add('dim');
  }
  
  if(i === 13 && !darkPhase){
    // Transition to scary background at dark phase + scary rising audio + demonic whispers
    scaryRising.currentTime = 0;
    scaryRising.play().catch(()=>{});
    
    // Start demonic whispers loop
    demonicWhispers.volume = 0.4;
    demonicWhispers.currentTime = 0;
    demonicWhispers.play().catch(()=>{});
    
    bgEl.classList.add('fade');
    setTimeout(()=>{
      bgEl.style.backgroundImage = "url('./assets/scarybackground.png')";
      bgEl.classList.remove('fade');
      bgEl.classList.add('dim');
    }, 200);
  }

  if(i === 15 && !darkPhase){
    // Ensure scary background is active
    darkPhase = true;
  }

  // Static blink effect when transitioning from false calm to angry
  if(i === 7){
    flashGlitch(100);
  }

  // Phase transitions based on line index
  if(i === 7 && phase === 'light'){ setPhase('angry'); }
  if(i === 13 && phase !== 'dark'){ setPhase('dark'); }
  if(i === 15 && phase === 'dark'){
    // Fade BGM to silence at Scene 10, keep only whispers
    fadeBGMToSilence(350);
  }
  if(i === 18 && phase !== 'demon'){ setPhase('demon'); }
  
  // Name ripple effect on Line 11 ("Noah")
  if(i === 11 && lines[i].includes('Noah')){
    // Drop BGM -4dB for 300ms, widen whispers +10%
    if (bgmGainNode){
      const now = audioCtx.currentTime;
      const currentGain = bgmGainNode.gain.value;
      bgmGainNode.gain.cancelScheduledValues(now);
      bgmGainNode.gain.linearRampToValueAtTime(currentGain * 0.6, now + 0.05); // -4dB drop
      bgmGainNode.gain.linearRampToValueAtTime(currentGain, now + 0.35); // Settle after 300ms
    }
    // Widen whispers if playing
    if (demonicWhispers && !demonicWhispers.paused){
      // Note: Stereo widening would require Web Audio stereo panner
      console.log('Name ripple: whispers widen +10%');
    }
  }

  // Play matching voice if provided
  if (voice[i]){
    try {
      talk.pause();
      talk = new Audio(voice[i]);
      talk.crossOrigin = 'anonymous';
      
      // Duck BGM when voice starts (skip if no music playing)
      if (musicPrimed && !music.paused){
        duckBGM(0.15, 120);
      }
      
      // Audio-driven mouth sprite swap
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const src = ctx.createMediaElementSource(talk);
      const analyser = ctx.createAnalyser();
      analyser.fftSize = 512;
      const data = new Uint8Array(analyser.frequencyBinCount);
      src.connect(analyser);
      analyser.connect(ctx.destination);
      
      let animFrame;
      const animate = ()=>{
        analyser.getByteFrequencyData(data);
        let sum = 0;
        for(let j=2; j<20; j++) sum += data[j];
        const energy = sum / 18 / 255;
        
        // For scary/demon sprites, keep them static (no mouth swap)
        // Lip-sync disables at start of Line 14 when phase becomes 'dark'
        if(baseSprite === 'scary' || baseSprite === 'demon'){
          aikoEl.src = `./assets/${baseSprite}.png`;
        } else {
          // Swap mouth sprites based on audio energy for normal emotions
          if(energy > 0.18){
            aikoEl.src = `./assets/openmouth.png`;
          } else if(energy > 0.08){
            aikoEl.src = `./assets/halfopen.png`;
          } else {
            aikoEl.src = `./assets/${baseSprite}.png`;
          }
        }
        
        if(!talk.paused && !talk.ended){
          animFrame = requestAnimationFrame(animate);
        } else {
          aikoEl.src = `./assets/${baseSprite}.png`;
        }
      };
      
      talk.play().catch(()=>{});
      animate();
      
      talk.addEventListener('ended', ()=>{
        cancelAnimationFrame(animFrame);
        aikoEl.src = `./assets/${baseSprite}.png`;
        // Unduck BGM when voice ends (skip if no music playing)
        if (musicPrimed && !music.paused){
          unduckBGM(350);
        }
      }, {once:true});
    } catch(e){
      console.warn('Audio setup failed', e);
    }
  } else {
    // No voice, just set emotion sprite
    aikoEl.src = `./assets/${baseSprite}.png`;
  }
}

function flashGlitch(ms=120){
  sfxGlitch.currentTime = 0; sfxGlitch.play().catch(()=>{});
  glitchEl.classList.add('flash');
  rgbEl.classList.add('on');
  setTimeout(()=>{ glitchEl.classList.remove('flash'); rgbEl.classList.remove('on'); }, ms);
  if (staticNoise){
    try {
      staticNoise.currentTime = 0;
      staticNoise.play().catch(()=>{});
      setTimeout(()=>{
        staticNoise.pause();
        staticNoise.currentTime = 0;
      }, Math.min(ms * 3, 900));
    } catch(e){}
  }
}

function toStaticTransition(){
  setPhase('static');
  inputLocked = true; // Lock input during transition
  
  // 1-frame (16ms) white ping before black (tube discharge)
  bgEl.style.backgroundColor = '#fff';
  aikoEl.style.opacity = 0;
  
  setTimeout(()=>{
    // 90ms black frame for shock
    bgEl.style.backgroundColor = '#000';
    
    // JUMPSCARE HIT at start of black frame (in vacuum)
    jumpScare.currentTime = 0;
    jumpScare.play().catch(()=>{});
    
    setTimeout(()=>{
      // Hard cut: stop ALL audio immediately
      stopAllAudio();
      
      // Slam to static image (120ms fade)
      bgEl.classList.add('fade');
      setTimeout(()=>{
        bgEl.style.backgroundImage = "url('./assets/staticimage.png')";
        bgEl.style.backgroundColor = '';
        bgEl.classList.remove('fade');
        
        // Play static noise 30ms after visual cut (tighter timing)
        setTimeout(()=>{
          if (staticNoise){
            staticNoise.currentTime = 0;
            staticNoise.volume = 0.6; // Capped to prevent ear crush
            staticNoise.play().catch(()=>{});
          }
        }, 30);
      }, 120);
      
      // After 3 seconds of static, transition to bedroom
      setTimeout(()=>{
        inputLocked = false;
        toBedroom();
      }, 3000);
    }, 90);
  }, 16);
}

function toBedroom(){
  setPhase('bedroom');
  darkPhase = true;
  
  // Stop static noise cleanly
  if (staticNoise){
    staticNoise.pause();
    staticNoise.currentTime = 0;
  }
  
  // Play transition boom
  transitionBoom.currentTime = 0;
  transitionBoom.play().catch(()=>{});
  
  // Start low hum (non-tonal drone)
  hum.volume = .55; 
  hum.play().catch(()=>{});
  
  bgEl.classList.add('fade');
  setTimeout(()=>{
    bgEl.style.backgroundImage = "url('./assets/bg_bedroom.png')";
    bgEl.classList.remove('fade');
    bgEl.classList.add('dim');
    aikoEl.style.opacity = .15; // ghost for 1s
    setTimeout(()=>{ 
      aikoEl.style.opacity = 0;
      setPhase('final');
    }, 900);
    if (window.__aikoLive2D){
      window.__aikoLive2D.alpha = 0.15;
      setTimeout(()=>{ window.__aikoLive2D.alpha = 0; }, 900);
    }
  }, 200);
}

/* --------- FLOW --------- */
// Preload heavy assets
function preloadAssets(){
  const preloadImages = [
    './assets/scarybackground.png',
    './assets/staticimage.png',
    './assets/bg_bedroom.png',
    './assets/scary.png',
    './assets/demon.png'
  ];
  
  preloadImages.forEach(src => {
    const img = new Image();
    img.src = src;
  });
  
  console.log('Preloading heavy assets...');
}

function init(){
  preloadAssets();
  ensureMusic();
  
  // iOS/Safari audio unlock on first gesture
  document.addEventListener('pointerdown', unlockAudio, { once:true });
  document.addEventListener('keydown', unlockAudio, { once:true });
  
  document.addEventListener('pointerdown', ensureMusic, { once:true });
  document.addEventListener('keydown', ensureMusic, { once:true });
  document.addEventListener('pointerdown', ensureFirstAudio, { once:true });
  document.addEventListener('keydown', ensureFirstAudio, { once:true });
  
  say(idx); // line 0 (text only, audio will play on first click)
  
  // idle micro "breathing"
  setInterval(()=>{
    aikoEl.style.transform = 'scale(1.01)';
    setTimeout(()=> aikoEl.style.transform='scale(1)', 600);
  }, 3500);
}
init();

/* --------- BUTTON LOGIC --------- */
btnIgnore.addEventListener('click', withLock(()=>{
  sfxClick.currentTime=0; sfxClick.play().catch(()=>{});
  ignoreCount++;
  if (ignoreCount===1){ idx=1; }         // "That's not very nice"
  else if (ignoreCount===2){ idx=2; }    // "Why are you being so mean..."
  else if (ignoreCount===3){             // hurts + glitch
    idx=4; 
    inputLocked = true;
    flashGlitch(140);
    setTimeout(()=>{ inputLocked = false; }, 190); // Unlock 60ms before debounce (250ms)
  } else {
    // After 3 ignores, keep light flickers and progress normally
    flashGlitch(100);
    idx = Math.min(idx+1, lines.length-1);
  }
  say(idx);
}, 250));

btnChange.addEventListener('click', withLock(()=>{
  sfxClick.currentTime=0; sfxClick.play().catch(()=>{});
  
  // TV field-roll effect (120ms vertical sync skid)
  textEl.classList.add('fade');
  bgEl.style.transform = 'translateY(-10px)';
  bgEl.style.transition = 'transform 120ms steps(3)';
  
  setTimeout(()=>{
    bgEl.style.transform = 'translateY(0)';
    bgEl.style.transition = '';
    
    idx=7; // "Why are you trying to talk to someone else…"
    say(idx);
    // start subtle desaturation & tension
    bgEl.classList.add('dim');
  }, 120);
}, 250));

// Click anywhere advances ONLY in Angry/Dark/Demon phases (not Light)
document.getElementById('app').addEventListener('click', withLock((e)=>{
  const isBtn = e.target.tagName.toLowerCase()==='button';
  if(isBtn) return; // buttons already handle
  
  // Light phase (0-6): buttons only, no tap-to-advance
  if (phase === 'light' && idx < 7) return;
  
  // Angry/Dark/Demon phases: tap to advance
  if (idx>=7 && idx<19){
    idx++; 
    say(idx);
    if (idx===11){ 
      inputLocked = true;
      flashGlitch(140);
      // 500ms silence hold after name reveal
      setTimeout(()=>{ 
        inputLocked = false; 
      }, 690); // Unlock 60ms before debounce (750ms total)
    }
    if (idx===14){ 
      inputLocked = true;
      flashGlitch(160);
      setTimeout(()=>{ inputLocked = false; }, 190); // Unlock 60ms before debounce
    }
    if (idx===18){                          // demon reveal
      inputLocked = true; // Lock during entire transition
      
      // Wait for voice to finish, then transition
      // aiko_18.mp3 is ~5s, add 120ms buffer
      const voiceDuration = 5000; // Adjust based on actual file length
      
      // Silence all beds 40ms before transition for vacuum effect
      setTimeout(()=>{
        if (music && !music.paused) music.volume = 0;
        if (demonicWhispers && !demonicWhispers.paused) demonicWhispers.volume = 0;
      }, voiceDuration - 40);
      
      // Trigger static transition after voice finishes
      setTimeout(()=>{
        toStaticTransition();
      }, voiceDuration + 120);
    }
  }
}, 250));

// End: fade to black on last whisper (with 320ms hold)
const fadeToBlack = ()=>{
  // Hold 320ms on empty room before fade
  setTimeout(()=>{
    const end = document.createElement('div');
    end.style.position='absolute'; end.style.inset='0'; end.style.background='#000'; end.style.opacity='0';
    end.style.transition='opacity .6s linear';
    document.body.appendChild(end);
    requestAnimationFrame(()=> end.style.opacity='1');
  }, 320);
};
document.addEventListener('ended', (e)=>{ if(e.target===talk && idx===lines.length-1){ fadeToBlack(); } }, true);

// Idle breathing animation
setInterval(()=>{
  if(aikoEl.src.includes('aiko.png')){
    aikoEl.style.transform = 'scale(1.005)';
    setTimeout(()=> aikoEl.style.transform='scale(1)', 1200);
  }
}, 3500);
</script>
</body>
</html>
