<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Don't Press Ignore</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0b0b12; --ui:#ffffff; --txt:#1B1B1B;
      --accent:#FF8FB1; --hover:#A3B7FF;
    }
    *{box-sizing:border-box}
    html,body{margin:0;height:100%;background:#000;font-family:Inter,system-ui,Segoe UI,Arial}
    .app{position:relative; width:100vw; height:100vh; overflow:hidden; background:#000;}
    canvas, .layer{position:absolute; inset:0}
    .bg{background:#000 center/cover no-repeat; filter:none; transition:filter .25s ease, opacity .2s}
    .bg.dim{filter:grayscale(.2) brightness(.9)}
    .bg.fade{opacity:0}
    .aiko{display:flex; align-items:flex-end; justify-content:center; pointer-events:none; position:absolute; bottom:180px; left:0; right:0; height:calc(100vh - 180px)}
    .aiko img{max-height:75vh; max-width:50vw; object-fit:contain; transition:opacity .15s; position:relative; z-index:1}
    .aiko img.talking{/* No animation - removed breathing effect */}
    .aiko img.hide{display:none !important}
    .aiko img.desaturated{filter:grayscale(0.3)}
    .aiko img.on-screen{
      max-height:35vh; max-width:40vw;
      position:absolute; top:25%; left:30%;
      transform-origin:center center;
    }
    .aiko canvas{position:absolute; inset:0; margin:auto; width:100%; height:100%; max-width:1280px; max-height:80vh; pointer-events:none; display:block}
    .ui{position:absolute; left:0; right:0; bottom:0; padding:22px; display:flex; justify-content:center; transition:opacity .2s}
    .ui.hidden{opacity:0; pointer-events:none}
    .dialogue{
      width:min(1200px,92vw); background:#fffF; backdrop-filter:blur(6px);
      border-radius:14px; box-shadow:0 10px 40px rgba(0,0,0,.35); padding:18px 18px 14px;
      border:1px solid rgba(0,0,0,.06)
    }
    .name{display:inline-block; background:var(--accent); color:#fff; border-radius:999px; padding:6px 14px; font-weight:700; margin-bottom:8px}
    .name.dark{background:#666}
    .text{min-height:64px; font-size:18px; line-height:1.4; color:#111; letter-spacing:.2px; opacity:1; transition:opacity .18s}
    .text.fade{opacity:0}
    .btns{display:flex; gap:10px; justify-content:flex-end; margin-top:10px}
    button{
      appearance:none; border:0; border-radius:12px; padding:10px 16px; font-weight:700; cursor:pointer;
      background:var(--accent); color:#fff; box-shadow:0 6px 16px rgba(255,143,177,.35); transition:transform .05s ease, filter .1s ease, background .15s
    }
    .secondary{background:var(--hover); box-shadow:0 6px 16px rgba(163,183,255,.35)}
    button:active{transform:scale(.98)}
    .scan{position:absolute; inset:0; pointer-events:none; background:
      repeating-linear-gradient(to bottom, rgba(255,255,255,.03) 0 2px, transparent 2px 4px);
      mix-blend-mode:overlay; opacity:.15}
    .vignette{position:absolute; inset:0; pointer-events:none; box-shadow:inset 0 0 220px rgba(0,0,0,.8)}
    .glitch{position:absolute; inset:0; pointer-events:none; opacity:0; background:#fff}
    .glitch.flash{animation:flash .12s steps(2) 1}
    @keyframes flash {0%{opacity:.9} 100%{opacity:0}}
    .rgb{position:absolute; inset:0; mix-blend-mode:screen; pointer-events:none; opacity:0}
    .rgb.on{opacity:.25; animation:rgb .12s steps(2) 1}
    @keyframes rgb{
      0%{transform:translate(0,0)}
      50%{transform:translate(2px,0)}
      100%{transform:translate(0,0)}
    }
    .hud{position:absolute; top:14px; left:14px; color:#fff; font-size:12px; opacity:.35}
    
    /* Title Screen */
    .title-screen{
      position:fixed; inset:0; z-index:9999;
      background:#000 center/cover no-repeat;
      display:flex; align-items:center; justify-content:center;
      cursor:pointer; opacity:1;
      transition:opacity .6s ease;
    }
    .title-screen.hide{opacity:0; pointer-events:none}
    .title-screen .prompt{
      position:absolute; bottom:40px; left:50%; transform:translateX(-50%);
      color:#fff; font-size:18px; font-weight:600; letter-spacing:1px;
      text-shadow:0 2px 8px rgba(0,0,0,.8);
      animation:pulse 2s ease-in-out infinite;
    }
    @keyframes pulse{
      0%, 100%{opacity:.6}
      50%{opacity:1}
    }
    
    /* Accessibility: reduce motion preference */
    @media (prefers-reduced-motion: reduce){
      *{transition:none !important; animation:none !important}
    }
  </style>
</head>
<body>
<!-- Title Screen -->
<div class="title-screen" id="titleScreen" style="background-image:url('./assets/titlegamebackground.png')">
  <div class="prompt">Click anywhere to start</div>
</div>

<div class="app" id="app">
  <div class="layer bg" id="bg" style="background-image:url('./assets/bg_school.jpg')"></div>
  <div class="layer aiko">
    <img id="aiko" src="./assets/aiko.png" alt="Aiko">
  </div>
  <div class="layer scan"></div>
  <div class="layer vignette"></div>
  <div class="layer glitch" id="glitch"></div>
  <div class="layer rgb" id="rgb"></div>

  <div class="ui" id="ui">
    <div class="dialogue">
      <div class="name" id="nameplate">Aiko</div>
      <div class="text" id="text"></div>
      <div class="btns" id="btns">
        <button id="ignoreBtn">Ignore</button>
        <button class="secondary" id="changeBtn">Change Character</button>
      </div>
    </div>
  </div>

  <div class="hud" id="hud">Use buttons to respond</div>
</div>

<audio id="sfxClick" src="./assets/click.mp3" preload="auto"></audio>
<audio id="sfxGlitch" src="./assets/glitch.mp3" preload="auto"></audio>
<audio id="music" src="./assets/audio/classroomidlemusic.mp3" preload="auto" loop></audio>
<audio id="roomTone" src="./assets/audio/classroomidlemusic.mp3" preload="auto" loop></audio>
<audio id="hum" src="./assets/hum_low.mp3" preload="auto" loop></audio>
<audio id="staticNoise" src="./assets/audio/staticnoise.mp3" preload="auto"></audio>
<audio id="scaryRising" src="./assets/audio/DSGNRise-scary_creepy_rising_-Elevenlabs.mp3" preload="auto"></audio>
<audio id="jumpScare" src="./assets/audio/GOREMisc-Jump_scare_Hit-FX,_S-Elevenlabs.mp3" preload="auto"></audio>
<audio id="transitionBoom" src="./assets/audio/GOREMisc-transition_boom_to_n-Elevenlabs.mp3" preload="auto"></audio>
<audio id="demonicWhispers" src="./assets/audio/demonicwhispers.mp3" preload="auto" loop></audio>

<script>
/* --------- STATE & SCRIPT --------- */
const voice = [
  "./assets/audio/aiko_01.mp3",  // 0: Opening
  "./assets/audio/aiko_02.mp3",  // 1: Ignore #1
  "./assets/audio/aiko_03.mp3",  // 2: Ignore #2 line 1
  "./assets/audio/aiko_03.mp3",  // 3: Ignore #2 line 2
  "./assets/audio/aiko_04.mp3",  // 4: Ignore #3
  "./assets/audio/aiko_05.mp3",  // 5: Are you tired? (aiko_05 contains both lines 5+6)
  "./assets/audio/aiko_05.mp3",  // 6: You look pale (same file, second part)
  "./assets/audio/aiko_06.mp3",  // 7: Why talk to someone else?
  "./assets/audio/aiko_07.mp3",  // 8: You already have me
  "./assets/audio/aiko_09.mp3",  // 9: You always leave
  "./assets/audio/aiko_10.mp3",  // 10: Meant for each other
  "./assets/audio/aiko_11.mp3",  // 11: Noah don't make me mad
  "./assets/audio/aiko_12.mp3",  // 12: I know you better
  "./assets/audio/aiko_13.mp3",  // 13: I know
  "./assets/audio/aiko_14.mp3",  // 14: I'll fix you
  "./assets/audio/aiko_15.mp3",  // 15: Stay with me
  "./assets/audio/aiko_16.mp3",  // 16: Don't have to answer
  "./assets/audio/aiko_17.mp3",  // 17: I'll do the talking
  "./assets/audio/Youre Mine Noah.mp3"  // 18: You're mine Noah (final dialogue line)
];

const lines = [
  "Hi… do you miss me? I miss you. Why don't you talk to me anymore?",
  "That's not very nice.",
  "Why are you being so mean to me?",
  "Don't you love me anymore?",
  "Why do you keep hurting me?",
  "Are you tired? Are you mad? Did you eat yet?",
  "You look pale again… you should rest.",
  "Why are you trying to talk to someone else?",
  "You already have me.",
  "You always leave… but you still come back.",
  "We're meant for each other, right?",
  "Noah... don't make me mad.",
  "I know you better than anyone.",
  "I know.",
  "I'll fix you.",
  "Just… stay with me, okay?",
  "You don't have to answer anymore.",
  "I'll do the talking.",
  "You're mine, Noah."
  // Line 19 removed - bedroom scene is automatic with no dialogue
];

const emotions = [
  {start: 0, end: 1, base: 'aiko'},      // Normal opening
  {start: 2, end: 4, base: 'clingy'},    // Needy/hurt
  {start: 5, end: 6, base: 'aiko'},      // False calm
  {start: 7, end: 12, base: 'angry'},    // Possessive/escalation
  {start: 13, end: 17, base: 'scary'},   // Dark phase
  {start: 18, end: 19, base: 'demon'}    // Demon reveal
];

function getBaseSprite(i){
  for(let e of emotions){
    if(i >= e.start && i <= e.end) return e.base;
  }
  return 'aiko';
}

// DOM elements
const textEl = document.getElementById('text');
const aikoEl = document.getElementById('aiko');
const bgEl = document.getElementById('bg');
const glitchEl = document.getElementById('glitch');
const rgbEl = document.getElementById('rgb');
const uiEl = document.getElementById('ui');
const btnsEl = document.getElementById('btns');
const hudEl = document.getElementById('hud');
const nameplate = document.getElementById('nameplate');

const sfxClick = document.getElementById('sfxClick');
const sfxGlitch = document.getElementById('sfxGlitch');
const music = document.getElementById('music');
const roomTone = document.getElementById('roomTone');
const hum = document.getElementById('hum');
const staticNoise = document.getElementById('staticNoise');
const scaryRising = document.getElementById('scaryRising');
const jumpScare = document.getElementById('jumpScare');
const transitionBoom = document.getElementById('transitionBoom');
const demonicWhispers = document.getElementById('demonicWhispers');

const btnIgnore = document.getElementById('ignoreBtn');
const btnChange = document.getElementById('changeBtn');

// State
let idx = 0;
let ignoreCount = 0;
let darkPhase = false;
let phase = 'light'; // 'light', 'angry', 'dark', 'demon', 'static', 'bedroom', 'final'
let talk = new Audio();
let talkSourceNode = null; // Track talk audio source node
let inputLocked = false;
let queuedAdvance = false;
let musicPrimed = false;
let firstInteraction = false;
let audioCtx = null;
let bgmGainNode = null;
let bgmFilterNode = null;
let bgmSourceNode = null;
let currentVoiceEndTimeout = null;
let currentAnimFrame = null; // Track animation frame for cleanup

/* --------- AUDIO SYSTEM --------- */
function unlockAudio(){
  if (!audioCtx){
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    
    // Create BGM gain and filter nodes
    bgmGainNode = audioCtx.createGain();
    bgmFilterNode = audioCtx.createBiquadFilter();
    bgmFilterNode.type = 'lowpass';
    bgmFilterNode.frequency.value = 22000; // Start unfiltered
    bgmFilterNode.Q.value = 1;
    
    // Connect: source → filter → gain → destination
    bgmFilterNode.connect(bgmGainNode);
    bgmGainNode.connect(audioCtx.destination);
    bgmGainNode.gain.value = 0.40; // Base 40% (increased for better audibility)
    
    // Connect music to Web Audio
    if (!bgmSourceNode && music){
      bgmSourceNode = audioCtx.createMediaElementSource(music);
      bgmSourceNode.connect(bgmFilterNode);
    }
  }
  if (audioCtx.state === 'suspended'){
    audioCtx.resume().catch(()=>{});
  }
}

// Warm buffers on first interaction (prevent stutter)
function warmBuffers(){
  const buffers = [music, roomTone, talk, demonicWhispers, scaryRising];
  buffers.forEach(buf => {
    if (buf && buf.play){
      const origVol = buf.volume;
      buf.volume = 0;
      buf.play().then(()=>{
        setTimeout(()=>{
          buf.pause();
          buf.currentTime = 0;
          buf.volume = origVol;
        }, 10);
      }).catch(()=>{});
    }
  });
}

function duckBGM(targetGain = 0.25, attackMs = 120){
  if (!bgmGainNode || !musicPrimed || music.paused) return;
  const now = audioCtx.currentTime;
  bgmGainNode.gain.cancelScheduledValues(now);
  bgmGainNode.gain.setValueAtTime(bgmGainNode.gain.value, now);
  bgmGainNode.gain.linearRampToValueAtTime(targetGain, now + attackMs/1000);
  console.log('[BGM] Ducking to', targetGain);
}

function unduckBGM(releaseMs = 350){
  if (!bgmGainNode || !musicPrimed || music.paused) return;
  const now = audioCtx.currentTime;
  const targetGain = (phase === 'angry' || phase === 'dark') ? 0.30 : 0.40;
  bgmGainNode.gain.cancelScheduledValues(now);
  bgmGainNode.gain.setValueAtTime(bgmGainNode.gain.value, now);
  bgmGainNode.gain.linearRampToValueAtTime(targetGain, now + releaseMs/1000);
  console.log('[BGM] Unducking to', targetGain);
}

function fadeBGMToSilence(durationMs = 350){
  if (!bgmGainNode || !musicPrimed) return;
  const now = audioCtx.currentTime;
  bgmGainNode.gain.cancelScheduledValues(now);
  bgmGainNode.gain.setValueAtTime(bgmGainNode.gain.value, now);
  bgmGainNode.gain.linearRampToValueAtTime(0.0001, now + durationMs/1000);
  setTimeout(()=>{
    if (music) music.pause();
  }, durationMs);
}

function applyBGMFilter(freqHz = 1200, gainDb = -8){
  if (!bgmFilterNode || !bgmGainNode) return;
  const now = audioCtx.currentTime;
  bgmFilterNode.frequency.cancelScheduledValues(now);
  bgmFilterNode.frequency.setValueAtTime(bgmFilterNode.frequency.value, now);
  bgmFilterNode.frequency.linearRampToValueAtTime(freqHz, now + 0.25);
  
  // Apply additional gain reduction
  const currentGain = bgmGainNode.gain.value;
  const targetGain = currentGain * Math.pow(10, gainDb/20);
  bgmGainNode.gain.cancelScheduledValues(now);
  bgmGainNode.gain.setValueAtTime(currentGain, now);
  bgmGainNode.gain.linearRampToValueAtTime(targetGain, now + 0.25);
}

function stopAllAudio(){
  [music, roomTone, hum, demonicWhispers, scaryRising, talk].forEach(a => {
    if (a && a.pause){
      a.pause();
      a.currentTime = 0;
    }
  });
}

function ensureMusic(){
  if (musicPrimed) return;
  unlockAudio();
  music.volume = 1; // Controlled by gain node
  music.play().catch(()=>{});
  
  // Room tone (HVAC) for Light phase only
  roomTone.volume = 0.01; // Very quiet, -40 LUFS equivalent
  roomTone.play().catch(()=>{});
  
  musicPrimed = true;
}

function ensureFirstAudio(){
  if (firstInteraction) return;
  firstInteraction = true;
  ensureMusic();
  warmBuffers();
}

/* --------- PHASE MANAGEMENT --------- */
function setPhase(newPhase){
  phase = newPhase;
  console.log(`[Phase] → ${phase}`);
  
  // Reset background classes
  bgEl.className = 'layer bg';
  
  // UI visibility based on phase
  if (phase === 'light'){
    btnsEl.style.display = 'flex';
    hudEl.textContent = 'Use buttons to respond';
    nameplate.textContent = 'Aiko';
    nameplate.classList.remove('dark');
    uiEl.classList.remove('hidden');
  } else if (phase === 'angry' || phase === 'dark'){
    btnsEl.style.display = 'none';
    hudEl.textContent = 'Tap to continue';
    nameplate.textContent = 'Aiko';
    nameplate.classList.add('dark');
    uiEl.classList.remove('hidden');
  } else if (phase === 'demon' || phase === 'static'){
    btnsEl.style.display = 'none';
    hudEl.textContent = '';
    nameplate.classList.add('dark');
    uiEl.classList.remove('hidden');
  } else if (phase === 'bedroom'){
    // Hide UI completely in bedroom (real life scene)
    uiEl.classList.add('hidden');
    hudEl.textContent = '';
  } else if (phase === 'final'){
    // Hide UI completely in final (real life scene)
    uiEl.classList.add('hidden');
    hudEl.textContent = '';
  }
  
  // Apply phase-specific filters/effects
  if (phase === 'angry'){
    applyBGMFilter(1200, -8);
    bgEl.classList.add('dim');
  } else if (phase === 'dark'){
    // BGM already filtered from angry, will fade at Line 15
    bgEl.classList.add('dim');
  }
}

/* --------- VISUAL EFFECTS --------- */
function flashGlitch(ms=120){
  sfxGlitch.currentTime = 0;
  sfxGlitch.play().catch(()=>{});
  glitchEl.classList.add('flash');
  rgbEl.classList.add('on');
  setTimeout(()=>{
    glitchEl.classList.remove('flash');
    rgbEl.classList.remove('on');
  }, ms);
}

function preloadAssets(){
  const heavyImages = [
    './assets/demon.png',
    './assets/scary.png',
    './assets/scarybackground.png',
    './assets/staticimage.png',
    './assets/bg_bedroom.png'
  ];
  heavyImages.forEach(src => {
    const img = new Image();
    img.src = src;
  });
}

/* --------- INPUT MANAGEMENT --------- */
function withLock(fn, debounceMs = 250){
  return function(...args){
    if (inputLocked){
      queuedAdvance = true;
      return;
    }
    inputLocked = true;
    fn(...args);
    setTimeout(()=>{
      inputLocked = false;
      if (queuedAdvance){
        queuedAdvance = false;
        inputLocked = true;
        fn(...args);
        setTimeout(()=>{ inputLocked = false; }, debounceMs);
      }
    }, debounceMs);
  };
}

/* --------- DIALOGUE SYSTEM --------- */
function say(i){
  ensureFirstAudio();
  
  // Micro-holds for ignore strikes (variable timing)
  let microHold = 0;
  if (i === 1) microHold = 80;   // Ignore #1
  if (i === 2) microHold = 220;  // Ignore #2
  if (i === 4) microHold = 120;  // Ignore #3
  
  // Ambient mute before Line 5 (false calm tension vacuum)
  if (i === 5){
    if (demonicWhispers && !demonicWhispers.paused){
      demonicWhispers.volume = 0;
    }
    setTimeout(()=>{
      if (demonicWhispers && !demonicWhispers.paused){
        demonicWhispers.volume = 0.4;
      }
    }, 250);
  }
  
  setTimeout(()=>{
    // Fade out old text
    textEl.classList.add('fade');
    setTimeout(()=>{
      textEl.textContent = lines[i] || "";
      textEl.classList.remove('fade');
    }, 140);
    
    // Determine base emotion sprite
    const baseSprite = getBaseSprite(i);
    
    // Background transitions
    if (i === 13){
      // Dark phase begins
      bgEl.classList.add('fade');
      setTimeout(()=>{
        bgEl.style.backgroundImage = "url('./assets/scarybackground.png')";
        bgEl.classList.remove('fade');
        bgEl.classList.add('dim');
      }, 200);
    }
    
    // Phase transitions
    if (i === 7){
      setPhase('angry');
      // Stop room tone
      if (roomTone){
        roomTone.pause();
        roomTone.currentTime = 0;
      }
    }
    if (i === 12){
      // Start demonic whispers BEFORE scary Aiko (build suspense)
      demonicWhispers.volume = 0.3; // Quieter at first
      demonicWhispers.play().catch(()=>{});
    }
    if (i === 13){
      setPhase('dark');
      // Increase whispers volume when scary Aiko appears
      demonicWhispers.volume = 0.4;
    }
    if (i === 15){
      // Fade BGM to silence, only whispers remain
      fadeBGMToSilence(350);
    }
    if (i === 18){
      setPhase('demon');
    }
    
    // Name reveal ripple (Line 11: "Noah")
    if (i === 11){
      // BGM dip -4dB for 300ms on already-filtered bus
      if (bgmGainNode && musicPrimed && !music.paused){
        const now = audioCtx.currentTime;
        const currentGain = bgmGainNode.gain.value;
        const dippedGain = currentGain * 0.63; // -4dB
        bgmGainNode.gain.cancelScheduledValues(now);
        bgmGainNode.gain.setValueAtTime(currentGain, now);
        bgmGainNode.gain.linearRampToValueAtTime(dippedGain, now + 0.05);
        bgmGainNode.gain.linearRampToValueAtTime(currentGain, now + 0.35);
      }
      // Widen whispers (console log as stereo panner requires more setup)
      console.log('[Name Ripple] Whispers widen +10% for 300ms');
    }
    
    // Play matching voice if provided
    if (voice[i]){
      try {
        // Clean up previous animation frame
        if (currentAnimFrame){
          cancelAnimationFrame(currentAnimFrame);
          currentAnimFrame = null;
        }
        
        // Stop previous talk audio cleanly
        if (talk && talk.pause){
          talk.pause();
          talk.currentTime = 0;
        }
        
        // Create new audio element for this line
        talk = new Audio(voice[i]);
        talk.crossOrigin = 'anonymous';
        talk.volume = 1.0; // Full volume for dialogue
        
        // Duck BGM when voice starts
        if (musicPrimed && !music.paused){
          duckBGM(0.25, 120); // Duck to 25% (audible background)
        }
        
        // Ensure audio context exists
        if (!audioCtx){
          unlockAudio();
        }
        
        // Audio-driven mouth sprite swap (disabled for scary/demon)
        // Create new source node for this audio element
        const src = audioCtx.createMediaElementSource(talk);
        const analyser = audioCtx.createAnalyser();
        analyser.fftSize = 512;
        const data = new Uint8Array(analyser.frequencyBinCount);
        src.connect(analyser);
        analyser.connect(audioCtx.destination);
        
        const animate = ()=>{
          analyser.getByteFrequencyData(data);
          let sum = 0;
          for(let j=2; j<20; j++) sum += data[j];
          const energy = sum / 18 / 255;
          
          // Lip-sync disabled at Line 13 (start of Dark phase)
          if(i >= 13){
            aikoEl.src = `./assets/${baseSprite}.png`;
          } else {
            // Swap mouth sprites based on audio energy
            if(energy > 0.18){
              aikoEl.src = `./assets/openmouth.png`;
            } else if(energy > 0.08){
              aikoEl.src = `./assets/halfopen.png`;
            } else {
              aikoEl.src = `./assets/${baseSprite}.png`;
            }
            
            // Apply desaturation to angry sprite
            if (baseSprite === 'angry'){
              aikoEl.classList.add('desaturated');
            } else {
              aikoEl.classList.remove('desaturated');
            }
          }
          
          if(!talk.paused && !talk.ended){
            currentAnimFrame = requestAnimationFrame(animate);
          } else {
            aikoEl.src = `./assets/${baseSprite}.png`;
            if (baseSprite === 'angry'){
              aikoEl.classList.add('desaturated');
            } else {
              aikoEl.classList.remove('desaturated');
            }
            currentAnimFrame = null;
          }
        };
        
        talk.play().catch(e => {
          console.error('Failed to play dialogue audio:', e);
        });
        animate();
        
        talk.addEventListener('ended', ()=>{
          if (currentAnimFrame){
            cancelAnimationFrame(currentAnimFrame);
            currentAnimFrame = null;
          }
          aikoEl.src = `./assets/${baseSprite}.png`;
          if (baseSprite === 'angry'){
            aikoEl.classList.add('desaturated');
          } else {
            aikoEl.classList.remove('desaturated');
          }
          
          // Unduck BGM when voice ends
          if (musicPrimed && !music.paused){
            unduckBGM(350);
          }
          
          // Scary rising starts 50ms after "I know." ends (Line 13)
          if (i === 13){
            setTimeout(()=>{
              scaryRising.currentTime = 0;
              scaryRising.volume = 0.6;
              scaryRising.play().catch(()=>{});
            }, 50);
          }
          
          // Auto-transition to static after Line 18 (Demon) voice ends
          if (i === 18){
            // Clear any existing timeout
            if (currentVoiceEndTimeout){
              clearTimeout(currentVoiceEndTimeout);
            }
            // Silence beds 40ms before transition
            setTimeout(()=>{
              if (demonicWhispers){
                demonicWhispers.pause();
                demonicWhispers.currentTime = 0;
              }
            }, 80); // 120ms buffer - 40ms pre-silence
            
            // Trigger static transition 120ms after voice ends
            currentVoiceEndTimeout = setTimeout(()=>{
              toStaticTransition();
            }, 120);
          }
        }, {once:true});
      } catch(e){
        console.error('Audio setup failed for line', i, ':', e);
        // Fallback: try to play without Web Audio API
        if (talk && talk.play){
          talk.play().catch(err => console.error('Fallback play failed:', err));
        }
      }
    } else {
      // No voice, just set emotion sprite
      aikoEl.src = `./assets/${baseSprite}.png`;
      if (baseSprite === 'angry'){
        aikoEl.classList.add('desaturated');
      } else {
        aikoEl.classList.remove('desaturated');
      }
    }
  }, microHold);
}

/* --------- TRANSITIONS --------- */
function toStaticTransition(){
  setPhase('static');
  inputLocked = true;
  
  // 1-frame (16ms) white ping before black (tube discharge)
  bgEl.style.backgroundColor = '#fff';
  aikoEl.style.opacity = 0;
  
  setTimeout(()=>{
    // 90ms black frame for shock
    bgEl.style.backgroundColor = '#000';
    
    // JUMPSCARE HIT at start of black frame (in vacuum)
    jumpScare.currentTime = 0;
    jumpScare.volume = 0.8;
    jumpScare.play().catch(()=>{});
    
    setTimeout(()=>{
      // Hard cut: stop ALL audio immediately
      stopAllAudio();
      
      // Slam to static image (120ms fade)
      bgEl.classList.add('fade');
      setTimeout(()=>{
        bgEl.style.backgroundImage = "url('./assets/staticimage.png')";
        bgEl.style.backgroundColor = '';
        bgEl.classList.remove('fade');
        
        // Play static noise 30ms after visual cut
        setTimeout(()=>{
          if (staticNoise){
            staticNoise.currentTime = 0;
            staticNoise.volume = 0.6; // Peak capped at -6dBFS
            staticNoise.play().catch(()=>{});
          }
        }, 30);
      }, 120);
      
      // After 3 seconds of static, transition to bedroom (auto)
      setTimeout(()=>{
        toBedroom();
      }, 3000);
    }, 90);
  }, 16);
}

function toBedroom(){
  setPhase('bedroom');
  darkPhase = true;
  
  // Stop static noise cleanly
  if (staticNoise){
    staticNoise.pause();
    staticNoise.currentTime = 0;
  }
  
  // Play transition boom
  transitionBoom.currentTime = 0;
  transitionBoom.volume = 0.7;
  transitionBoom.play().catch(()=>{});
  
  // Start low hum (mono, non-tonal drone)
  hum.volume = 0.55;
  hum.play().catch(()=>{});
  
  bgEl.classList.add('fade');
  setTimeout(()=>{
    bgEl.style.backgroundImage = "url('./assets/bg_bedroom.png')";
    bgEl.classList.remove('fade');
    bgEl.classList.add('dim');
    
    // Position demon Aiko on computer screen and fade out
    aikoEl.classList.add('on-screen');
    aikoEl.style.opacity = 0.15;
    aikoEl.style.transform = 'translateY(0px)';
    
    let driftY = 0;
    const driftInterval = setInterval(()=>{
      driftY += 0.05;
      if (driftY > 3) driftY = 3;
      aikoEl.style.transform = `translateY(${driftY}px)`;
    }, 30);
    
    setTimeout(()=>{
      clearInterval(driftInterval);
      aikoEl.style.opacity = 0;
      setPhase('final');
      
      // Auto fade to black after bedroom scene (no user interaction needed)
      setTimeout(()=>{
        fadeToBlack();
      }, 2000); // 2 seconds of empty room before fade
    }, 900);
  }, 200);
}

function fadeToBlack(){
  // 320ms hold before fade
  setTimeout(()=>{
    const end = document.createElement('div');
    end.style.position='absolute';
    end.style.inset='0';
    end.style.background='#000';
    end.style.opacity='0';
    end.style.transition='opacity .6s linear';
    end.style.zIndex='10000';
    document.body.appendChild(end);
    requestAnimationFrame(()=> end.style.opacity='1');
  }, 320);
}

/* --------- INIT --------- */
function init(){
  preloadAssets();
  
  // Unlock audio and start music immediately
  unlockAudio();
  
  // Start background music immediately
  if (!musicPrimed){
    music.volume = 1; // Controlled by gain node
    music.loop = true; // Ensure looping
    music.play().then(()=>{
      console.log('[BGM] Music started successfully');
    }).catch(e => {
      console.log('[BGM] Music autoplay blocked:', e);
    });
    
    // Room tone (HVAC) for Light phase only
    roomTone.volume = 0.01; // Very quiet, -40 LUFS equivalent
    roomTone.play().catch(()=>{});
    
    musicPrimed = true;
  }
  
  // Check if music is actually playing
  setInterval(()=>{
    if (musicPrimed && music.paused && phase !== 'bedroom' && phase !== 'final'){
      console.warn('[BGM] Music paused unexpectedly, restarting...');
      music.play().catch(()=>{});
    }
  }, 1000);
  
  // Show opening dialogue immediately with text
  textEl.textContent = lines[0];
  aikoEl.src = './assets/aiko.png';
  
  // Auto-play opening audio after a brief delay (allow UI to render)
  setTimeout(()=>{
    // Ensure audio context is unlocked
    unlockAudio();
    
    // Ensure music is playing
    if (music.paused){
      music.play().catch(()=>{});
    }
    
    // Warm buffers
    warmBuffers();
    
    // Play opening voice line automatically
    if (voice[0]){
      talk = new Audio(voice[0]);
      talk.crossOrigin = 'anonymous';
      talk.volume = 1.0; // Full volume for dialogue
      
      // Duck BGM when voice starts
      if (musicPrimed && !music.paused){
        duckBGM(0.25, 120); // Duck to 25% (audible background)
      }
      
      // Ensure audio context exists
      if (!audioCtx){
        unlockAudio();
      }
      
      // Audio-driven mouth sprite swap
      try {
        const src = audioCtx.createMediaElementSource(talk);
        const analyser = audioCtx.createAnalyser();
        analyser.fftSize = 512;
        const data = new Uint8Array(analyser.frequencyBinCount);
        src.connect(analyser);
        analyser.connect(audioCtx.destination);
        
        let animFrame;
        const animate = ()=>{
          analyser.getByteFrequencyData(data);
          let sum = 0;
          for(let j=2; j<20; j++) sum += data[j];
          const energy = sum / 18 / 255;
          
          if(energy > 0.18){
            aikoEl.src = `./assets/openmouth.png`;
          } else if(energy > 0.08){
            aikoEl.src = `./assets/halfopen.png`;
          } else {
            aikoEl.src = `./assets/aiko.png`;
          }
          
          if(!talk.paused && !talk.ended){
            animFrame = requestAnimationFrame(animate);
          } else {
            aikoEl.src = `./assets/aiko.png`;
          }
        };
        
        talk.play().catch(()=>{});
        animate();
        
        talk.addEventListener('ended', ()=>{
          cancelAnimationFrame(animFrame);
          aikoEl.src = `./assets/aiko.png`;
          
          // Unduck BGM when voice ends
          if (musicPrimed && !music.paused){
            unduckBGM(350);
          }
        }, {once:true});
      } catch(e){
        console.warn('Opening audio setup failed', e);
        talk.play().catch(()=>{});
      }
    }
  }, 500); // 500ms delay after game starts to play opening audio
  
  // Removed idle breathing animation - Aiko stays static
}

/* --------- TITLE SCREEN LOGIC --------- */
const titleScreen = document.getElementById('titleScreen');
let gameStarted = false;

// Start music immediately on page load (title screen)
function startTitleMusic(){
  unlockAudio();
  if (!musicPrimed){
    music.volume = 1;
    music.play().catch(e => {
      console.log('Music autoplay blocked on title screen, will retry on click');
    });
    musicPrimed = true;
  }
}

// Try to start music immediately
startTitleMusic();

// Also try on first user interaction if autoplay was blocked
document.addEventListener('pointerdown', startTitleMusic, { once: true });
document.addEventListener('keydown', startTitleMusic, { once: true });

function startGame(){
  if (gameStarted) return;
  gameStarted = true;
  
  // Ensure music is playing when starting game
  if (music.paused){
    music.play().catch(()=>{});
  }
  
  // Fade out title screen
  titleScreen.classList.add('hide');
  
  // After fade completes, remove from DOM and start game
  setTimeout(()=>{
    titleScreen.remove();
    init(); // Start the game
  }, 600);
}

// Auto-start game after 3 seconds
setTimeout(()=>{
  startGame();
}, 3000);

// Also allow manual start by clicking
titleScreen.addEventListener('click', startGame);
titleScreen.addEventListener('keydown', (e)=>{
  if (e.key === 'Enter' || e.key === ' ') startGame();
});

/* --------- BUTTON LOGIC --------- */
btnIgnore.addEventListener('click', withLock(()=>{
  sfxClick.currentTime=0; sfxClick.play().catch(()=>{});
  ignoreCount++;
  
  if (ignoreCount===1){
    idx=1;
  } else if (ignoreCount===2){
    idx=2;
  } else if (ignoreCount===3){
    idx=4;
    inputLocked = true;
    flashGlitch(140);
    setTimeout(()=>{ inputLocked = false; }, 190);
  } else {
    flashGlitch(100);
    idx = Math.min(idx+1, lines.length-1);
  }
  say(idx);
}, 250));

btnChange.addEventListener('click', withLock(()=>{
  sfxClick.currentTime=0; sfxClick.play().catch(()=>{});
  
  // TV field-roll effect (120ms vertical sync skid) - NO static blink
  textEl.classList.add('fade');
  bgEl.style.transform = 'translateY(-10px)';
  bgEl.style.transition = 'transform 120ms steps(3)';
  
  setTimeout(()=>{
    bgEl.style.transform = 'translateY(0)';
    bgEl.style.transition = '';
    
    idx=7; // "Why are you trying to talk to someone else…"
    say(idx);
  }, 120);
}, 250));

// Tap-to-advance ONLY in Angry/Dark/Final phases (NOT Light)
document.getElementById('app').addEventListener('click', withLock((e)=>{
  const isBtn = e.target.tagName.toLowerCase()==='button';
  if(isBtn) return;
  
  // Only allow tap-to-advance in specific phases
  if (phase !== 'angry' && phase !== 'dark' && phase !== 'final') return;
  
  if (idx >= 7 && idx < 18){
    idx++;
    say(idx);
    
    // Glitch flashes at specific moments
    if (idx === 11){
      inputLocked = true;
      flashGlitch(140);
      // 500ms silence hold after glitch
      setTimeout(()=>{
        inputLocked = false;
      }, 690); // 140ms glitch + 500ms silence + 50ms buffer
    }
    if (idx === 14){
      inputLocked = true;
      flashGlitch(160);
      setTimeout(()=>{
        inputLocked = false;
      }, 250);
    }
  }
  // Line 19 removed - bedroom scene is fully automatic, no tap needed
}, 250));

</script>
</body>
</html>
